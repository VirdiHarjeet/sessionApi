import Foundation
import UIKit

struct ApiManager {
    // MARK: Normal API
    static func upload<T: Decodable>(
        _ type: T.Type,
        requestProtocol: RequestProtocol
    ) async throws -> T {
        guard let request = getRequest(requestProtocol: requestProtocol) else {
            throw CustomError.invalidRequest
        }
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw CustomError.invalidResponse
        }
        
//        if httpResponse.statusCode == 401 {
 //            try await refreshToken()
//            // retry request once after refresh
//            return try await upload(type, requestProtocol: requestProtocol)
//        }
        
        do {
            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            throw CustomError.decodingError(error)
        }
    }
    
    // MARK: Multipart API
    static func uploadMultipart<T: Decodable>(
        _ type: T.Type,
        requestProtocol: RequestProtocol,
        media: [Media]?
    ) async throws -> T {
        guard let request = getMultipartRequest(media: media, requestProtocol: requestProtocol) else {
            throw CustomError.invalidRequest
        }
        let (data, _) = try await URLSession.shared.data(for: request)
        do {
            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            throw CustomError.decodingError(error)
        }
    }
    
    // MARK: Create Normal Request
    private static func getRequest(requestProtocol: RequestProtocol) -> URLRequest? {
        guard let url = URL(string: requestProtocol.path) else { return nil }
        
        var request = URLRequest(url: url)
        request.httpMethod = requestProtocol.method.rawValue
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(getTimeZone(), forHTTPHeaderField: "timezone")
        
        if let param = requestProtocol.param {
            request.httpBody = try? JSONSerialization.data(withJSONObject: param, options: .fragmentsAllowed)
        }
        
        if let header = requestProtocol.header {
            for (key, value) in header {
                request.addValue(value, forHTTPHeaderField: key)
            }
        }
        return request
    }
    
    // MARK: Create Multipart Request
    private static func getMultipartRequest(media: [Media]?, requestProtocol: RequestProtocol) -> URLRequest? {
        let boundary = getBoundary()
        guard let url = URL(string: requestProtocol.path) else { return nil }
        
        var request = URLRequest(url: url)
        request.httpMethod = requestProtocol.method.rawValue
        let lineBreak = "\r\n"
        var body = Data()
        
        if let parameters = requestProtocol.param {
            for (key, value) in parameters {
                body.append("--\(boundary + lineBreak)")
                body.append("Content-Disposition: form-data; name=\"\(key)\"\(lineBreak + lineBreak)")
                body.append("\(value)\(lineBreak)")
            }
        }
        
        if let media = media {
            for photo in media {
                body.append("--\(boundary + lineBreak)")
                body.append("Content-Disposition: form-data; name=\"\(photo.key)\"; filename=\"\(photo.fileName)\"\(lineBreak)")
                body.append("Content-Type: \(photo.mimeType + lineBreak + lineBreak)")
                body.append(photo.data)
                body.append(lineBreak)
            }
        }
        
        request.allHTTPHeaderFields = [
            "X-User-Agent": "ios",
            "Accept-Language": "en",
            "Accept": "application/json",
            "Content-Type": "multipart/form-data; boundary=\(boundary)",
        ]
        
        if let header = requestProtocol.header {
            for (key, value) in header {
                request.addValue(value, forHTTPHeaderField: key)
            }
        }
        
        body.append("--\(boundary)--\(lineBreak)")
        request.httpBody = body
        return request
    }
    
    // MARK: Helpers
    static func getBoundary() -> String {
        "Boundary-\(UUID().uuidString)"
    }
    
    static func getTimeZone() -> String {
        TimeZone.current.identifier
    }
}


// MARK: Media Multipart Api
struct Media{
    let key: String
    let mimeType: String
    let data: Data
    let fileName: String
    init?(forKey key: String, withImage image: UIImage = UIImage(), withMime mimeType:String, withVideo videoData:Data = Data()) {
        self.key = key
        self.mimeType = mimeType
        if let data = image.jpegData(compressionQuality: 0.5){
            self.data = data
            self.fileName = "\(arc4random()).jpeg"
        }else{
            self.data = videoData
            self.fileName = "\(arc4random()).mp4"
        }
    }
}

// MARK:  Convert string to Data
extension Data {
    mutating func append(_ string: String) {
        if let data = string.data(using: .utf8) {
            append(data)
        }
    }
}


// Mark:- Request Protocol
protocol RequestProtocol{
    var path: String { get }
    var method: HTTPMethod { get }
    var header: [String:String]? { get }
    var param: [String:Any]? { get }
}

extension RequestProtocol{
    var header: [String:String]? {
        return nil
    }
    
    var param: [String:Any]? {
        return nil
    }
}

  // Mark:- HTTP Method
enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case patch = "PATCH"
    case delete = "DELETE"
    case put = "PUT"
}
enum otpCase{
    case signup
 
    case login
}
enum CustomError: Error {
    case invalidRequest
    case apiError(Error)
    case decodingError(Error)
    case invalidResponse
}


// USE
 do {
            let user = try await ApiManager.upload(AuthModal.self, requestProtocol: request)
            appState.hideLoader()
            print(user)
            if user.status == true {
                register = true
            } else {
                appState.showAlert(title: Constants.Alert.error, message: user.message ?? "Login failed")
            }
        } catch {
            appState.hideLoader()
            appState.showAlert(title: Constants.Alert.error, message: error.localizedDescription)
        }
