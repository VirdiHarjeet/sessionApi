import Foundation
import UIKit

typealias Response<T:Decodable> = (Result<T,CustomError>) -> Void

struct ApiManager{
    // MARK: Normal APi
    static func upload<T:Decodable>(_ type:T.Type, requestProtocol: RequestProtocol , complition: @escaping Response<T>){
        guard let request = getRequest(requestProtocol: requestProtocol) else{ return }
        URLSession.shared.dataTask(with: request) { data, ressponse, error in
            complitionResponse(data: data, response: ressponse, error: error, complition: complition)
        }
        .resume()
    }
    
    // MARK: Multipart Api
    static func uploadMultipart<T:Decodable>(_ type:T.Type, requestProtocol: RequestProtocol ,media:[Media]? , complition: @escaping Response<T>){
        guard let request = getMultipartRequest(media: media, requestProtocol: requestProtocol) else{ return }
        URLSession.shared.dataTask(with: request) { data, ressponse, error in
            complitionResponse(data: data, response: ressponse, error: error, complition: complition)
        }
        .resume()
    }
    
    // MARK: Create Normal Request
    private static func getRequest(requestProtocol: RequestProtocol) -> URLRequest?{
        guard let Url = URL(string: requestProtocol.path) else{
            return nil
        }
        var request = URLRequest(url: Url)
        request.httpMethod = requestProtocol.method.rawValue
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(getTimeZone(), forHTTPHeaderField: "x-user-timezone")
        if let param = requestProtocol.param{
         let body = try? JSONSerialization.data(withJSONObject: param, options: .fragmentsAllowed)
            request.httpBody = body
        }
        if let header = requestProtocol.header{
            for (key , value) in header{
                request.addValue(value, forHTTPHeaderField: key)
            }
        }
        return request
    }
    
    // MARK: Api Response
    private static func complitionResponse<T:Decodable>(data:Data?, response:URLResponse?, error:Error?, complition: @escaping Response<T>){
        if let error{
            complition(.failure(.apiError(error)))
        }else if let data = data{
            do{
                let string = String(data: data, encoding: .utf8)
                print(string ?? "")
                let decode = try JSONDecoder().decode(T.self, from: data)
                complition(.success(decode))
            }catch{
                complition(.failure(.decodingError(error)))
            }
        }
    }
    
    // MARK: Create Multipart Request
    private static func getMultipartRequest(media: [Media]?, requestProtocol: RequestProtocol) -> URLRequest? {
        let boundary = getBoundary()
        guard let Url = URL(string: requestProtocol.path) else{
            return nil
        }
        var request = URLRequest(url: Url)
        request.httpMethod = requestProtocol.method.rawValue
        let lineBreak = "\r\n"
        var body = Data()
        if let parameters = requestProtocol.param {
            for (key, value) in parameters {
                body.append("--\(boundary + lineBreak)")
                body.append("Content-Disposition: form-data; name=\"\(key)\"\(lineBreak + lineBreak)")
                body.append("\((value as? String ?? "") + lineBreak)")
            }
        }
        
        if let media = media {
            for photo in media {
                body.append("--\(boundary + lineBreak)")
                body.append("Content-Disposition: form-data; name=\"\(photo.key)\"; filename=\"\(photo.fileName)\"\(lineBreak)")
                body.append("Content-Type: \(photo.mimeType + lineBreak + lineBreak)")
                body.append(photo.data)
                body.append(lineBreak)
            }
        }
        
        request.allHTTPHeaderFields = [
            "X-User-Agent": "ios",
            "Accept-Language": "en",
            "Accept": "application/json",
            "Content-Type": "multipart/form-data; boundary=\(boundary)",
        ]
        
        if let header = requestProtocol.header{
            for (key , value) in header{
                request.addValue(value, forHTTPHeaderField: key)
            }
        }
        
        body.append("--\(boundary)--\(lineBreak)")
        request.httpBody = body
        return request
    }
    
    // MARK: Genrate Boundary for Multipart Api
    static func getBoundary() -> String{
        return "Boundary-\(NSUUID().uuidString)"
    }
    
    static func getTimeZone() -> String{
        let timeZoneString = TimeZone.current.identifier
        return timeZoneString
    }
}

// MARK: Media Multipart Api
struct Media{
    let key: String
    let mimeType: String
    let data: Data
    let fileName: String
    init?(forKey key: String, withImage image: UIImage = UIImage(), withMime mimeType:String, withVideo videoData:Data = Data()) {
        self.key = key
        self.mimeType = mimeType
        if let data = image.jpegData(compressionQuality: 0.5){
            self.data = data
            self.fileName = "\(arc4random()).jpeg"
        }else{
            self.data = videoData
            self.fileName = "\(arc4random()).mp4"
        }
    }
}

// MARK:  Convert string to Data
extension Data {
    mutating func append(_ string: String) {
        if let data = string.data(using: .utf8) {
            append(data)
        }
    }
}


// Mark:- Request Protocol
protocol RequestProtocol{
  var path: String { get }
  var method: HTTPMethod { get }
  var header: [String:String]? { get }
  var param: [String:Any]? { get }
}

extension RequestProtocol{
  var header: [String:String]? {
      return nil
  }
  
  var param: [String:Any]? {
      return nil
  }
}

  // Mark:- HTTP Method
enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case patch = "PATCH"
    case delete = "DELETE"
    case put = "PUT"
}

  // Mark:- custom Error
enum CustomError: LocalizedError {
  case unexpected
  case apiError(Error)
  case decodingError(Error)
  
  var failureReason: String? {
    switch self {
    case .unexpected:
      return "Something went Wrong. Try Later"
    case .apiError(let error):
        return error.localizedDescription
    case .decodingError(let sucess):
        return sucess.localizedDescription
    }
  }
}

